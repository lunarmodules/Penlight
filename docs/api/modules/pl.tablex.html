<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>pl.tablex: Module Index</title>
    <link rel="stylesheet" href="../luadoc.css" type="text/css" />
	<!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h2>LuaDoc</h2>
<ul>
	
	<li><a href="../index.html">Index</a></li>
	
</ul>


<!-- Module list -->

<h2>Modules</h2>
<ul>

	<li>
		<a href="../modules/pl.app.html">pl.app</a>
	</li>

	<li>
		<a href="../modules/pl.array2d.html">pl.array2d</a>
	</li>

	<li>
		<a href="../modules/pl.class.html">pl.class</a>
	</li>

	<li>
		<a href="../modules/pl.classx.html">pl.classx</a>
	</li>

	<li>
		<a href="../modules/pl.config.html">pl.config</a>
	</li>

	<li>
		<a href="../modules/pl.data.html">pl.data</a>
	</li>

	<li>
		<a href="../modules/pl.dir.html">pl.dir</a>
	</li>

	<li>
		<a href="../modules/pl.file.html">pl.file</a>
	</li>

	<li>
		<a href="../modules/pl.func.html">pl.func</a>
	</li>

	<li>
		<a href="../modules/pl.input.html">pl.input</a>
	</li>

	<li>
		<a href="../modules/pl.lapp.html">pl.lapp</a>
	</li>

	<li>
		<a href="../modules/pl.lexer.html">pl.lexer</a>
	</li>

	<li>
		<a href="../modules/pl.list.html">pl.list</a>
	</li>

	<li>
		<a href="../modules/pl.operator.html">pl.operator</a>
	</li>

	<li>
		<a href="../modules/pl.path.html">pl.path</a>
	</li>

	<li>
		<a href="../modules/pl.permute.html">pl.permute</a>
	</li>

	<li>
		<a href="../modules/pl.pretty.html">pl.pretty</a>
	</li>

	<li>
		<a href="../modules/pl.seq.html">pl.seq</a>
	</li>

	<li>
		<a href="../modules/pl.sip.html">pl.sip</a>
	</li>

	<li>
		<a href="../modules/pl.stringio.html">pl.stringio</a>
	</li>

	<li>
		<a href="../modules/pl.stringx.html">pl.stringx</a>
	</li>

	<li><strong>pl.tablex</strong></li>
	
	<li>
		<a href="../modules/pl.test.html">pl.test</a>
	</li>

	<li>
		<a href="../modules/pl.text.html">pl.text</a>
	</li>

	<li>
		<a href="../modules/pl.utils.html">pl.utils</a>
	</li>

</ul>



<!-- File list -->






</div><!-- id="navigation" -->

<div id="content">

<h1>Module "pl.tablex"</h1>

<p>Extended operations on Lua tables.</p>





<h2>Functions</h2>
<table class="function_list">

	<tr>
	<td class="name" nowrap><a href="#tablex.clear">tablex.clear</a>&nbsp;(t, istart)</td>
	<td class="summary">clear out the contents of a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.compare">tablex.compare</a>&nbsp;(t1, t2, cmp)</td>
	<td class="summary">compare two list-like tables using a predicate.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.compare_no_order">tablex.compare_no_order</a>&nbsp;(t1, t2, cmp)</td>
	<td class="summary">compare two list-like tables using an optional predicate, without regard for element order.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.copy">tablex.copy</a>&nbsp;(t)</td>
	<td class="summary">make a shallow copy of a table </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.count_map">tablex.count_map</a>&nbsp;(t, cmp)</td>
	<td class="summary">A table where the key/values are the values and value counts of the table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.deepcompare">tablex.deepcompare</a>&nbsp;(t1, t2, ignore_mt)</td>
	<td class="summary">compare two values.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.deepcopy">tablex.deepcopy</a>&nbsp;(t)</td>
	<td class="summary">make a deep copy of a table, recursively copying all the keys and fields.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.difference">tablex.difference</a>&nbsp;(s1, s2, symm)</td>
	<td class="summary">a new table which is the difference of two tables.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.filter">tablex.filter</a>&nbsp;(t, pred, arg, optional)</td>
	<td class="summary">filter a table's values using a predicate function </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.find">tablex.find</a>&nbsp;(t, val, idx)</td>
	<td class="summary">return the index of a value in a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.find_if">tablex.find_if</a>&nbsp;(t, cmp, arg)</td>
	<td class="summary">return the index (or key) of a value in a table using a comparison function.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.foreach">tablex.foreach</a>&nbsp;(t, fun, ...)</td>
	<td class="summary">apply a function to all elements of a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.foreachi">tablex.foreachi</a>&nbsp;(t, fun, ...)</td>
	<td class="summary">apply a function to all elements of a list-like table in order.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.icopy">tablex.icopy</a>&nbsp;(dest, src, idest, isrc, nsrc, n)</td>
	<td class="summary">copy an array into another one, resizing the destination if necessary.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.imap">tablex.imap</a>&nbsp;(fun, t, ...)</td>
	<td class="summary">apply a function to all values of a list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.imap2">tablex.imap2</a>&nbsp;(fun, t1, t2, ...)</td>
	<td class="summary">apply a function to values from two arrays.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.index_by">tablex.index_by</a>&nbsp;(tbl, idx)</td>
	<td class="summary">return a list of all values in a table indexed by another list.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.index_map">tablex.index_map</a>&nbsp;(t)</td>
	<td class="summary">create an index map from a list-like table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.insertvalues">tablex.insertvalues</a>&nbsp;(t, ...)</td>
	<td class="summary">insert values into a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.keys">tablex.keys</a>&nbsp;(t)</td>
	<td class="summary">return all the keys of a table in arbitrary order.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.makeset">tablex.makeset</a>&nbsp;(t)</td>
	<td class="summary">create a set from a list-like table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.map">tablex.map</a>&nbsp;(fun, t, ...)</td>
	<td class="summary">apply a function to all values of a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.map2">tablex.map2</a>&nbsp;(fun, t1, t2, ...)</td>
	<td class="summary">apply a function to values from two tables.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.map_named_method">tablex.map_named_method</a>&nbsp;(name, t, ...)</td>
	<td class="summary">apply a named method to values from a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.mapn">tablex.mapn</a>&nbsp;(fun, ...)</td>
	<td class="summary">Apply a function to a number of tables.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.merge">tablex.merge</a>&nbsp;(t1, t2, dup)</td>
	<td class="summary">combine two tables, either as union or intersection.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.move">tablex.move</a>&nbsp;(dest, src, idest, isrc, nsrc, n)</td>
	<td class="summary">copy an array into another one.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.new">tablex.new</a>&nbsp;(n, val)</td>
	<td class="summary">create a new array of specified size with initial value.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.pairmap">tablex.pairmap</a>&nbsp;(fun, t, ...)</td>
	<td class="summary">call the function with the key and value pairs from a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.range">tablex.range</a>&nbsp;(start, finish, step)</td>
	<td class="summary">generate a table of all numbers in a range </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.reduce">tablex.reduce</a>&nbsp;(fun, t)</td>
	<td class="summary">'reduce' a list using a binary function.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.removevalues">tablex.removevalues</a>&nbsp;(t, i1, i2)</td>
	<td class="summary">remove a range of values from a table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.rfind">tablex.rfind</a>&nbsp;(t, val, idx)</td>
	<td class="summary">return the index of a value in a list, searching from the end.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.search">tablex.search</a>&nbsp;(t, value, exclude)</td>
	<td class="summary">find a value in a table by recursive search.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.set">tablex.set</a>&nbsp;(t, val, i1, i2)</td>
	<td class="summary">set an array range to a value.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.size">tablex.size</a>&nbsp;(t)</td>
	<td class="summary">total number of elements in this table.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.sub">tablex.sub</a>&nbsp;(t, first, last)</td>
	<td class="summary">Extract a range from a table, like  'string.sub'.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.transform">tablex.transform</a>&nbsp;(fun, t, ...)</td>
	<td class="summary">apply a function to all values of a table, in-place.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.update">tablex.update</a>&nbsp;(t1, t2)</td>
	<td class="summary">copy a table into another, in-place.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.values">tablex.values</a>&nbsp;(t)</td>
	<td class="summary">return all the values of the table in arbitrary order </td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#tablex.zip">tablex.zip</a>&nbsp;(...)</td>
	<td class="summary">return a table where each element is a table of the ith values of an arbitrary
number of tables.</td>
	</tr>

</table>






<br/>
<br/>



<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="tablex.clear"></a><strong>tablex.clear</strong>&nbsp;(t, istart)</dt>
<dd>
clear out the contents of a table.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a table
	</li>
	
	<li>
	  istart: 
	</li>
	
</ul>










</dd>




<dt><a name="tablex.compare"></a><strong>tablex.compare</strong>&nbsp;(t1, t2, cmp)</dt>
<dd>
compare two list-like tables using a predicate.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t1: a table
	</li>
	
	<li>
	  t2: a table
	</li>
	
	<li>
	  cmp: A comparison function
	</li>
	
</ul>










</dd>




<dt><a name="tablex.compare_no_order"></a><strong>tablex.compare_no_order</strong>&nbsp;(t1, t2, cmp)</dt>
<dd>
compare two list-like tables using an optional predicate, without regard for element order.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t1: a list-like table
	</li>
	
	<li>
	  t2: a list-like table
	</li>
	
	<li>
	  cmp: A comparison function (may be nil)
	</li>
	
</ul>










</dd>




<dt><a name="tablex.copy"></a><strong>tablex.copy</strong>&nbsp;(t)</dt>
<dd>
make a shallow copy of a table


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: source table
	</li>
	
</ul>








<h3>Return value:</h3>
new table



</dd>




<dt><a name="tablex.count_map"></a><strong>tablex.count_map</strong>&nbsp;(t, cmp)</dt>
<dd>
A table where the key/values are the values and value counts of the table.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a list-like table
	</li>
	
	<li>
	  cmp: a function that defines equality (otherwise uses ==)
	</li>
	
</ul>








<h3>Return value:</h3>
a map-like table



<h3>See also:</h3>
<ul>
	
	<li><a href="">
		seq.count_map
	</a>
	
</ul>

</dd>




<dt><a name="tablex.deepcompare"></a><strong>tablex.deepcompare</strong>&nbsp;(t1, t2, ignore_mt)</dt>
<dd>
compare two values.
if they are tables, then compare their keys and fields recursively.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t1: A value
	</li>
	
	<li>
	  t2: A value
	</li>
	
	<li>
	  ignore_mt: if true, ignore __eq metamethod (default false)
	</li>
	
</ul>








<h3>Return value:</h3>
true or false



</dd>




<dt><a name="tablex.deepcopy"></a><strong>tablex.deepcopy</strong>&nbsp;(t)</dt>
<dd>
make a deep copy of a table, recursively copying all the keys and fields.
This will also set the copied table's metatable to that of the original.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: A table
	</li>
	
</ul>








<h3>Return value:</h3>
new table



</dd>




<dt><a name="tablex.difference"></a><strong>tablex.difference</strong>&nbsp;(s1, s2, symm)</dt>
<dd>
a new table which is the difference of two tables.
With sets (where the values are all true) this is set difference and
symmetric difference depending on the third parameter.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  s1: a map-like table or set
	</li>
	
	<li>
	  s2: a map-like table or set
	</li>
	
	<li>
	  symm: symmetric difference (default false)
	</li>
	
</ul>








<h3>Return value:</h3>
a map-like table or set



</dd>




<dt><a name="tablex.filter"></a><strong>tablex.filter</strong>&nbsp;(t, pred, arg, optional)</dt>
<dd>
filter a table's values using a predicate function


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a list-like table
	</li>
	
	<li>
	  pred: a boolean function
	</li>
	
	<li>
	  arg: 
	</li>
	
	<li>
	  optional: argument to be passed as second argument of the predicate
	</li>
	
</ul>










</dd>




<dt><a name="tablex.find"></a><strong>tablex.find</strong>&nbsp;(t, val, idx)</dt>
<dd>
return the index of a value in a list.
Like string.find, there is an optional index to start searching,
which can be negative.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: A list-like table (i.e. with numerical indices)
	</li>
	
	<li>
	  val: A value
	</li>
	
	<li>
	  idx: index to start; -1 means last element,etc (default 1)
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li>find({10,20,30},20) == 2
	
	<li>find({'a','b','a','c'},'a',2) == 3
	
</ul>





<h3>Return value:</h3>
index of value or nil if not found



</dd>




<dt><a name="tablex.find_if"></a><strong>tablex.find_if</strong>&nbsp;(t, cmp, arg)</dt>
<dd>
return the index (or key) of a value in a table using a comparison function.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: A table
	</li>
	
	<li>
	  cmp: A comparison function
	</li>
	
	<li>
	  arg: an optional second argument to the function
	</li>
	
</ul>








<h3>Return values:</h3>
<ol>
	
	<li>index of value, or nil if not found
	
	<li>value returned by comparison function
	
</ol>



</dd>




<dt><a name="tablex.foreach"></a><strong>tablex.foreach</strong>&nbsp;(t, fun, ...)</dt>
<dd>
apply a function to all elements of a table.
The arguments to the function will be the value,
the key and <i>finally</i> any extra arguments passed to this function.
Note that the Lua 5.0 function table.foreach passed the <i>key</i> first.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a table
	</li>
	
	<li>
	  fun: a function with at least one argument
	</li>
	
	<li>
	  ...: extra arguments
	</li>
	
</ul>










</dd>




<dt><a name="tablex.foreachi"></a><strong>tablex.foreachi</strong>&nbsp;(t, fun, ...)</dt>
<dd>
apply a function to all elements of a list-like table in order.
The arguments to the function will be the value,
the index and <i>finally</i> any extra arguments passed to this function


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a table
	</li>
	
	<li>
	  fun: a function with at least one argument
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>










</dd>




<dt><a name="tablex.icopy"></a><strong>tablex.icopy</strong>&nbsp;(dest, src, idest, isrc, nsrc, n)</dt>
<dd>
copy an array into another one, resizing the destination if necessary. <br>


<h3>Parameters:</h3>
<ul>
	
	<li>
	  dest: a list-like table
	</li>
	
	<li>
	  src: a list-like table
	</li>
	
	<li>
	  idest: where to start copying values from source (default 1)
	</li>
	
	<li>
	  isrc: where to start copying values into destination (default 1)
	</li>
	
	<li>
	  nsrc: 
	</li>
	
	<li>
	  n: number of elements to copy from source (default source size)
	</li>
	
</ul>










</dd>




<dt><a name="tablex.imap"></a><strong>tablex.imap</strong>&nbsp;(fun, t, ...)</dt>
<dd>
apply a function to all values of a list.
This returns a table of the results.
Any extra arguments are passed to the function.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  fun: A function that takes at least one argument
	</li>
	
	<li>
	  t: a table (applies to array part)
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>




<h3>Usage:</h3>
imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}





<h3>Return value:</h3>
a list-like table



</dd>




<dt><a name="tablex.imap2"></a><strong>tablex.imap2</strong>&nbsp;(fun, t1, t2, ...)</dt>
<dd>
apply a function to values from two arrays.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  fun: a function of at least two arguments
	</li>
	
	<li>
	  t1: a list-like table
	</li>
	
	<li>
	  t2: a list-like table
	</li>
	
	<li>
	  ...: extra arguments
	</li>
	
</ul>




<h3>Usage:</h3>
imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}







</dd>




<dt><a name="tablex.index_by"></a><strong>tablex.index_by</strong>&nbsp;(tbl, idx)</dt>
<dd>
return a list of all values in a table indexed by another list.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  tbl: a table
	</li>
	
	<li>
	  idx: an index table (a list of keys)
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li>index_by({10,20,30,40},{2,4}) == {20,40}
	
	<li>index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
	
</ul>





<h3>Return value:</h3>
a list-like table



</dd>




<dt><a name="tablex.index_map"></a><strong>tablex.index_map</strong>&nbsp;(t)</dt>
<dd>
create an index map from a list-like table. The original values become keys,
and the associated values are the indices into the original list.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a list-like table
	</li>
	
</ul>








<h3>Return value:</h3>
a map-like table



</dd>




<dt><a name="tablex.insertvalues"></a><strong>tablex.insertvalues</strong>&nbsp;(t, ...)</dt>
<dd>
insert values into a table. <br>
insertvalues(t, [pos,] values) <br>
similar to table.insert but inserts values from given table "values",
not the object itself, into table "t" at position "pos".


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: 
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>










</dd>




<dt><a name="tablex.keys"></a><strong>tablex.keys</strong>&nbsp;(t)</dt>
<dd>
return all the keys of a table in arbitrary order.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: A table
	</li>
	
</ul>










</dd>




<dt><a name="tablex.makeset"></a><strong>tablex.makeset</strong>&nbsp;(t)</dt>
<dd>
create a set from a list-like table. A set is a table where the original values
become keys, and the associated values are all true.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a list-like table
	</li>
	
</ul>








<h3>Return value:</h3>
a set (a map-like table)



</dd>




<dt><a name="tablex.map"></a><strong>tablex.map</strong>&nbsp;(fun, t, ...)</dt>
<dd>
apply a function to all values of a table.
This returns a table of the results.
Any extra arguments are passed to the function.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  fun: A function that takes at least one argument
	</li>
	
	<li>
	  t: A table
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>




<h3>Usage:</h3>
map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}







</dd>




<dt><a name="tablex.map2"></a><strong>tablex.map2</strong>&nbsp;(fun, t1, t2, ...)</dt>
<dd>
apply a function to values from two tables.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  fun: a function of at least two arguments
	</li>
	
	<li>
	  t1: a table
	</li>
	
	<li>
	  t2: a table
	</li>
	
	<li>
	  ...: extra arguments
	</li>
	
</ul>




<h3>Usage:</h3>
map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}





<h3>Return value:</h3>
a table



</dd>




<dt><a name="tablex.map_named_method"></a><strong>tablex.map_named_method</strong>&nbsp;(name, t, ...)</dt>
<dd>
apply a named method to values from a table.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  name: the method name
	</li>
	
	<li>
	  t: a list-like table
	</li>
	
	<li>
	  ...: any extra arguments to the method
	</li>
	
</ul>










</dd>




<dt><a name="tablex.mapn"></a><strong>tablex.mapn</strong>&nbsp;(fun, ...)</dt>
<dd>
Apply a function to a number of tables.
A more general version of map
The result is a table containing the result of applying that function to the
ith value of each table. Length of output list is the minimum length of all the lists


<h3>Parameters:</h3>
<ul>
	
	<li>
	  fun: A function that takes as many arguments as there are tables
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li>mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
	
	<li>mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is	{100,200,300}
	
</ul>







</dd>




<dt><a name="tablex.merge"></a><strong>tablex.merge</strong>&nbsp;(t1, t2, dup)</dt>
<dd>
combine two tables, either as union or intersection. Corresponds to
set operations for sets () but more general. Not particularly
useful for list-like tables.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t1: a table
	</li>
	
	<li>
	  t2: a table
	</li>
	
	<li>
	  dup: true for a union, false for an intersection.
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li>merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
	
	<li>merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
	
</ul>







<h3>See also:</h3>
<ul>
	
	<li><a href="">
		tablex.index_map
	</a>
	
</ul>

</dd>




<dt><a name="tablex.move"></a><strong>tablex.move</strong>&nbsp;(dest, src, idest, isrc, nsrc, n)</dt>
<dd>
copy an array into another one. <br>


<h3>Parameters:</h3>
<ul>
	
	<li>
	  dest: a list-like table
	</li>
	
	<li>
	  src: a list-like table
	</li>
	
	<li>
	  idest: where to start copying values from source (default 1)
	</li>
	
	<li>
	  isrc: where to start copying values into destination (default 1)
	</li>
	
	<li>
	  nsrc: 
	</li>
	
	<li>
	  n: number of elements to copy from source (default source size)
	</li>
	
</ul>










</dd>




<dt><a name="tablex.new"></a><strong>tablex.new</strong>&nbsp;(n, val)</dt>
<dd>
create a new array of specified size with initial value.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  n: size
	</li>
	
	<li>
	  val: initial value (can be nil, but don't expect # to work!)
	</li>
	
</ul>








<h3>Return value:</h3>
the table



</dd>




<dt><a name="tablex.pairmap"></a><strong>tablex.pairmap</strong>&nbsp;(fun, t, ...)</dt>
<dd>
call the function with the key and value pairs from a table.
The function can return a value and a key (note the order!). If both
are not nil, then this pair is inserted into the result. If only value is not nil, then
it is appended to the result.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  fun: A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
	</li>
	
	<li>
	  t: A table
	</li>
	
	<li>
	  ...: 
	</li>
	
</ul>




<h3>Usage:</h3>
<ul>
	
	<li>pairmap({fred=10,bonzo=20},function(k,v) return v end) is {10,20}
	
	<li>pairmap({one=1,two=2},function(k,v) return {k,v},k end) is {one={'one',1},two={'two',2}}
	
</ul>







</dd>




<dt><a name="tablex.range"></a><strong>tablex.range</strong>&nbsp;(start, finish, step)</dt>
<dd>
generate a table of all numbers in a range


<h3>Parameters:</h3>
<ul>
	
	<li>
	  start: number
	</li>
	
	<li>
	  finish: number
	</li>
	
	<li>
	  step: optional increment (default 1 for increasing, -1 for decreasing)
	</li>
	
</ul>










</dd>




<dt><a name="tablex.reduce"></a><strong>tablex.reduce</strong>&nbsp;(fun, t)</dt>
<dd>
'reduce' a list using a binary function.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  fun: a function of two arguments
	</li>
	
	<li>
	  t: a list-like table
	</li>
	
</ul>




<h3>Usage:</h3>
reduce('+',{1,2,3,4}) == 10





<h3>Return value:</h3>
the result of the function



</dd>




<dt><a name="tablex.removevalues"></a><strong>tablex.removevalues</strong>&nbsp;(t, i1, i2)</dt>
<dd>
remove a range of values from a table.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a list-like table
	</li>
	
	<li>
	  i1: start index
	</li>
	
	<li>
	  i2: end index
	</li>
	
</ul>








<h3>Return value:</h3>
the table



</dd>




<dt><a name="tablex.rfind"></a><strong>tablex.rfind</strong>&nbsp;(t, val, idx)</dt>
<dd>
return the index of a value in a list, searching from the end.
Like string.find, there is an optional index to start searching,
which can be negative.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: A list-like table (i.e. with numerical indices)
	</li>
	
	<li>
	  val: A value
	</li>
	
	<li>
	  idx: index to start; -1 means last element,etc (default 1)
	</li>
	
</ul>




<h3>Usage:</h3>
rfind({10,10,10},10) == 3





<h3>Return value:</h3>
index of value or nil if not found



</dd>




<dt><a name="tablex.search"></a><strong>tablex.search</strong>&nbsp;(t, value, exclude)</dt>
<dd>
find a value in a table by recursive search.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: the table
	</li>
	
	<li>
	  value: the value
	</li>
	
	<li>
	  exclude: any tables to avoid searching
	</li>
	
</ul>




<h3>Usage:</h3>
search(_G,math.sin,{package.path}) == 'math.sin'





<h3>Return value:</h3>
a fieldspec, e.g. 'a.b' or 'math.sin'



</dd>




<dt><a name="tablex.set"></a><strong>tablex.set</strong>&nbsp;(t, val, i1, i2)</dt>
<dd>
set an array range to a value. If it's a function we use the result
of applying it to the indices.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a list-like table
	</li>
	
	<li>
	  val: a value
	</li>
	
	<li>
	  i1: start range (default 1)
	</li>
	
	<li>
	  i2: end range (default table size)
	</li>
	
</ul>










</dd>




<dt><a name="tablex.size"></a><strong>tablex.size</strong>&nbsp;(t)</dt>
<dd>
total number of elements in this table. <br>
Note that this is distinct from #t, which is the number
of values in the array part; this value will always
be greater or equal. The difference gives the size of
the hash part, for practical purposes.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a table
	</li>
	
</ul>








<h3>Return value:</h3>
the size



</dd>




<dt><a name="tablex.sub"></a><strong>tablex.sub</strong>&nbsp;(t, first, last)</dt>
<dd>
Extract a range from a table, like  'string.sub'.
If first or last are negative then they are relative to the end of the list
eg. sub(t,-2) gives last 2 entries in a list, and
sub(t,-4,-2) gives from -4th to -2nd


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: a list-like table
	</li>
	
	<li>
	  first: An index
	</li>
	
	<li>
	  last: An index
	</li>
	
</ul>








<h3>Return value:</h3>
a new List



</dd>




<dt><a name="tablex.transform"></a><strong>tablex.transform</strong>&nbsp;(fun, t, ...)</dt>
<dd>
apply a function to all values of a table, in-place.
Any extra arguments are passed to the function.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  fun: A function that takes at least one argument
	</li>
	
	<li>
	  t: a table
	</li>
	
	<li>
	  ...: extra arguments
	</li>
	
</ul>










</dd>




<dt><a name="tablex.update"></a><strong>tablex.update</strong>&nbsp;(t1, t2)</dt>
<dd>
copy a table into another, in-place.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t1: destination table
	</li>
	
	<li>
	  t2: source table
	</li>
	
</ul>








<h3>Return value:</h3>
first table



</dd>




<dt><a name="tablex.values"></a><strong>tablex.values</strong>&nbsp;(t)</dt>
<dd>
return all the values of the table in arbitrary order


<h3>Parameters:</h3>
<ul>
	
	<li>
	  t: A table
	</li>
	
</ul>










</dd>




<dt><a name="tablex.zip"></a><strong>tablex.zip</strong>&nbsp;(...)</dt>
<dd>
return a table where each element is a table of the ith values of an arbitrary
number of tables. It is equivalent to a matrix transpose.


<h3>Parameters:</h3>
<ul>
	
	<li>
	  ...: 
	</li>
	
</ul>




<h3>Usage:</h3>
zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}







</dd>


</dl>






</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->	
</body>
</html>
